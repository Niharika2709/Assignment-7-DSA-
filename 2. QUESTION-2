2. A slightly improved selection sort â€“ We know that selection sort algorithm takes the minimum on 
every pass on the array, and place it at its correct position. The idea is to take also the maximum on 
every pass and place it at its correct position. So in every pass, we keep track of both maximum and 
minimum and array becomes sorted from both ends. Implement this logic. 

#include <iostream>
using namespace std;

void improvedSelectionSort(int arr[], int n) {
    int left = 0;          // Start of the array
    int right = n - 1;     // End of the array

    while (left < right) {
        int minIndex = left;
        int maxIndex = right;

        // If first element is greater than last, swap indices
        if (arr[minIndex] > arr[maxIndex])
            swap(minIndex, maxIndex);

        // Find min & max in remaining unsorted part
        for (int i = left + 1; i <= right - 1; i++) {
            if (arr[i] < arr[minIndex])
                minIndex = i;
            else if (arr[i] > arr[maxIndex])
                maxIndex = i;
        }

        // Place minimum at left
        swap(arr[left], arr[minIndex]);

        // FIX: if max element was swapped due to min swap
        if (maxIndex == left)
            maxIndex = minIndex;

        // Place maximum at right
        swap(arr[right], arr[maxIndex]);

        // Move inwards
        left++;
        right--;
    }
}

int main() {
    int arr[] = {29, 10, 14, 37, 14, 5, 8};
    int n = sizeof(arr) / sizeof(arr[0]);

    improvedSelectionSort(arr, n);

    cout << "Array after Improved Selection Sort: ";
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
    
    return 0;
}
